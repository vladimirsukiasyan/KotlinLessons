/**
 *  Код в блоках инициализации фактически становится частью основного конструктора.
 *  Дополнительный конструктор ссылается на основной при помощи
 *  своего первого оператора, поэтому код во всех блоках инициализации,
 *  а также инициализация свойств выполняется перед выполнением кода в теле дополнительного конструктора.
 *  Даже если у класса нет основного конструктора на него все равно
 *  происходит неявная ссылка и блоки инициализации выполняются также
 */
class Constructors {
    init {
        println("Блок инициализации")
    }

    constructor(i: Int) {
        println("Конструктор")
    }
}

/**
 * Если у класса есть основной конструктор, каждый дополнительный конструктор
 * должен прямо или косвенно ссылаться (через другой(ие) конструктор(ы)) на основной.
 * Осуществляется это при помощи ключевого слова this:
 */
class Person(val name: String) {
    var children: MutableList<Person> = mutableListOf()
    constructor(name: String, parent: Person): this(name){
        parent.children.add(this)
        println("secondary constructor")
    }
}

// Запрещает вызов конструктора - ронов как и создание объекта обычным способом
class DontCreateMe private constructor () {
}

fun main() {
    val parent = Person("Jack") //вызывается основной конструктор
    val child = Person("Mike", parent) // вызывается дополнительный конструктор, но перед ним основной через this(name)
    Constructors(1)
}